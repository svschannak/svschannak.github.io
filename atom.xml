<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Hacking am Buffet]]></title>
  <link href="http://svschannak.github.io/atom.xml" rel="self"/>
  <link href="http://svschannak.github.io/"/>
  <updated>2014-01-23T10:51:46+01:00</updated>
  <id>http://svschannak.github.io/</id>
  <author>
    <name><![CDATA[Sven Schannak]]></name>
    
  </author>

  
  <entry>
    <title type="html"><![CDATA[Erste Fortschritte...]]></title>
    <link href="http://svschannak.github.io/blog/2014/01/22/erste-fortschritte-dot-dot-dot/"/>
    <updated>2014-01-22T23:30:06+01:00</updated>
    <id>http://svschannak.github.io/blog/2014/01/22/erste-fortschritte-dot-dot-dot</id>
    <content type="html"><![CDATA[<p>&hellip; sind nur schwer erkennbar. Objective-C ist für einen Software-Entwickler vom Typ &ldquo;Sven&rdquo; eine unangenehme Sprache. Da gibt es dieses Sender-Prinzip und ganz viel Syntax-Rumgedöhns, welches wirklich alles andere als sexy ist. Sei es drum, nicht jeder kann so hübsch sein wie mein Python. Man muss grundlegend verstehen wie eine App funktioniert. MVC ist dort die strikte Grundlage auf der alles aufbaut.</p>

<p>Es gibt sogenannte ViewController und die können ineinander verschachtelt sein. Das wirkt auf den ersten Blick sinnvoll und wenn man verstanden hat, wie man ordentlich mit XCode arbeitet, bemerkt man schnell, dass man auch so relativ sauberen Code schreibt und zum Beispiel ganze Views für ähnliche Aufgaben im selben Projekt relativ einfach wiederverwenden kann. Ungewohnt für mich ist irgendwie das fehlende Routing. Oder es gibt vielleicht doch eins, irgendwie, aber das versteckt sich vielleicht hinter der Magie von XCode.</p>

<p>Ich habe es zumindestens geschafft eine App zu schreiben, die Daten in verschiedenen Typen von Views ausgeben kann und verstanden wie ein Table View Delegate genutzt wird. Ich bin eigentlich schon sehr gespannt viele neue Libraries, Tools und andere Werkzeuge kennenzulernen, weil vieles nach den Prinzipien von Uncle Bob in mir noch ein gewisses Unwohlsein hervorruft.</p>

<p>Als Nächstes ist der Kurs zu Models von Codeschool dran. Ich denke mal, das wird mich doch schon einen ganzen Schritt weiter bringen, nach dem ich den tryiOS-Kurs durchgezogen habe, welcher mir sehr gut gefallen hat, auch wenn leider ein ganzes Wochenende lang die Kurse nicht funktionierten, da sich bei Codeschool ein paar Mac Minis aus dem Staub gemacht hatten.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Das Projekt]]></title>
    <link href="http://svschannak.github.io/blog/2014/01/04/das-projekt/"/>
    <updated>2014-01-04T10:57:59+01:00</updated>
    <id>http://svschannak.github.io/blog/2014/01/04/das-projekt</id>
    <content type="html"><![CDATA[<p>Seit Jahren fange ich immer wieder mit dem selben Projekt bei neuen Frameworks oder Programmiersprachen an. Ich setze eine kleine Anwendung zur Buchungsverwaltung und zu Buchungsanfragen um. Das hat einen sehr einfachen Grund. Bei Buchungen geht es um Kommunikation, um eine konsistente Datenhaltung, eine auf hohe Erreichbarkeit optimierte Oberfläche und das Einhalten von Prozessen um zum Beispiel Doppelbuchungen zu vermeiden.</p>

<p>Das bedeutet ich benötige bei allen Projekten folgende Vorraussetzungen um zu starten:</p>

<ul>
<li>Eine persistente Datenbank (PostgreSQL, SQLite etc.)</li>
<li>Eine Möglichkeit mit der Außenwelt zu kommunizieren (Mail, Rest-API etc.)</li>
<li>Ein Framework um eine ansprechende UI umzusetzen (z.B. Rails mit HTML, CSS, JS)</li>
<li>Eine Art State-Machine um Prozessabläufe und die verschiedenen States integrieren zu können</li>
</ul>


<p>Die ersten 3 Vorraussetzungen sind unabdingbar, die 4. Vorraussetzung ist für mich wünschenswert. Für die Umsetzung werde ich neben der Sprache, das jeweils populärste Framework einsetzen zur Entwicklung von Web-/Desktop-/Mobile-Anwendungen.</p>

<p>Grundlegend geht es bei der Buchungsverwaltung um 2 Probleme:</p>

<ul>
<li>Das Vermeiden von Doppelbuchungen</li>
<li>Für bereits belegte Termine alternative Vorschläge senden</li>
</ul>


<p>Das erste Problem ist logisch und muss nicht weiter erklärt werden. Das 2. Problem kann etwas komplexer ausfallen. Um dieses Problem zu lösen, muss man mit Hilfe eines kleinen Datensatzes verstehen, warum jemand ein spezifisches Objekt für einen spezifischen Zeitraum gebucht hat. Hat er zum Beispiel einen Saal für 100 Personen von Donnerstag bis Samstag Abend gebucht, kann man davon ausgehen, dass dort eine Konferenz stattfindet. Also kann ich ihm einen anderen Konferenzsaal vorschlagen oder einen anderen Termin für den Saal, am besten wieder von Donnerstag bis Samstag oder von Freitag bis Sonntag. Montag bis Mittwoch wäre eher nicht so gut.</p>

<p>Den Prozess habe ich versucht in der BPM-Notation darzustellen. (Verzeiht mir meinen laienhaften Versuch ;) ).</p>

<p><img src="http://svschannak.github.io/images/das_projekt_prozessbeschreibung.jpg" alt="Der Prozess in BPMN" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ein Projekt in 7 Sprachen in 52 Wochen]]></title>
    <link href="http://svschannak.github.io/blog/2014/01/04/ein-projekt-in-7-sprachen-in-52-wochen/"/>
    <updated>2014-01-04T10:36:23+01:00</updated>
    <id>http://svschannak.github.io/blog/2014/01/04/ein-projekt-in-7-sprachen-in-52-wochen</id>
    <content type="html"><![CDATA[<p>Effektivität. Oder doch Effizienz? Bei der Effektivität ging es doch darum, die richtigen Dinge zu tun. Für mich persönlich ist der beste Vorsatz, und das jedes Jahr, neue Dinge zu lernen. Bei der Effizienz geht es wiederum darum, dass ich die Dinge auch richtig tue. Also ist irgendwie beides wichtig. Ich will ja nicht nur irgendwie lernen, sondern möglichst viel von den richtigen Dingen lernen.</p>

<p>Als selbst ernannter Software-Entwickler kann es da nur um Software-Entwicklung gehen. In diesem Jahr will ich mich speziell mit 7 Programmiersprachen beschäftigen, die ich bis jetzt nur stiefmütterlich behandelt oder aus weiter Entfernung betrachtet habe. Da das Jahr 52 Wochen hat und ich ja irgendwie Urlaub und Krankheit mit einberechnen muss, habe ich für jede Sprache 7 Wochen Zeit. Am Ende will ich zumindestens die grundlegenden Prinzipien hinter folgenden Sprachen verstanden haben:</p>

<ol>
<li>Objective-C</li>
<li>Go</li>
<li>Elixir</li>
<li>Haskell</li>
<li>Ruby</li>
<li>Node.js</li>
<li>Java</li>
</ol>


<p>Mit 4 von diesen Programmiersprachen habe ich zwar bereits gearbeitet, aber nie in einem umfangreichen Rahmen. Um die Konzepte hinter den jeweiligen Sprachen besser verstehen zu können, werde ich jeweils eine Anwendung in diesen Sprachen umsetzen. Ob daraus eine Webanwendung oder eine Anwendung für den Desktop oder für ein Device entsteht, mache ich vom bevorzugten Einsatzfeld der jeweiligen Sprache abhängig. Am Ende soll aber immer wieder das gleiche Problem gelöst werden und der selbe Prozess abgebildet werden. In den nächsten 52 Wochen will ich nun <del>mindestens 49 Posts an Samstagen</del> ab und zu ein paar Posts veröffentlichen um über meine Fortschritte zu berichten.</p>

<p>Was ich heute von den Programmiersprachen halte, will ich einfach ignorieren und ohne Vorbehalte loslegen. Ich bin extrem gespannt und hoffe extrem viel für meine tägliche Arbeit zu lernen.</p>

<p>In meinem ersten Post geht es um das Problem und den Prozess der jeweils gelöst werden soll.</p>
]]></content>
  </entry>
  
</feed>
